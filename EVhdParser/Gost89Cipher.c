#include "Gost89Cipher.h"
#include "utils.h"

/*
Forward declaration of the cipher implementation
*/

typedef UCHAR byte;
typedef ULONG word32;

/* Encrypts several blocks in ECB mode */
void gost_enc(Gost89CipherContext * c, const byte * clear, byte * cipher, int blocks);
/* Decrypts several blocks in ECB mode */
void gost_dec(Gost89CipherContext * c, const byte * cipher, byte * clear, int blocks);
/* Encrypts several full blocks in CFB mode using 8byte IV */
void gost_enc_cfb(Gost89CipherContext * ctx, const byte * iv, const byte * clear,
	byte * cipher, int blocks);
/* Decrypts several full blocks in CFB mode using 8byte IV */
void gost_dec_cfb(Gost89CipherContext * ctx, const byte * iv, const byte * cipher,
	byte * clear, int blocks);
/* Set 256 bit  key into context */
void gost_key(Gost89CipherContext * c, const byte * k);

/** Subtitution blocks */
typedef struct {
	UCHAR		k8[16];
	UCHAR		k7[16];
	UCHAR		k6[16];
	UCHAR		k5[16];
	UCHAR		k4[16];
	UCHAR		k3[16];
	UCHAR		k2[16];
	UCHAR		k1[16];
} gost_subst_block;

extern gost_subst_block GostR3411_94_TestParamSet;
extern gost_subst_block GostR3411_94_CryptoProParamSet;
extern gost_subst_block Gost28147_TestParamSet;
extern gost_subst_block Gost28147_CryptoProParamSetA;
extern gost_subst_block Gost28147_CryptoProParamSetB;
extern gost_subst_block Gost28147_CryptoProParamSetC;
extern gost_subst_block Gost28147_CryptoProParamSetD;
extern gost_subst_block tc26_gost28147_paramZ;

static void kboxinit(Gost89CipherContext * c, const gost_subst_block * b);

static const ULONG32 PoolTag = 'Gost';

NTSTATUS Gost89CipherCreate(PVOID cipherConfig, PVOID *pOutContext)
{
	Gost89CipherConfig *gostConfig = (Gost89CipherConfig *)cipherConfig;
	Gost89CipherContext *c = NULL;
	const gost_subst_block *sBlock = NULL;
	BOOLEAN bIsCfb = FALSE;
	if (!cipherConfig || !pOutContext)
		return STATUS_INVALID_PARAMETER;

	switch (gostConfig->SBlock)
	{
	case ESBlock_GostR3411_94_TestParamSet:
		sBlock = &GostR3411_94_TestParamSet;
		break;
	case ESBlock_Gost28147_89_CryptoPro_A_ParamSet:
		sBlock = &Gost28147_CryptoProParamSetA;
		break;
	case ESBlock_Gost28147_89_CryptoPro_B_ParamSet:
		sBlock = &Gost28147_CryptoProParamSetB;
		break;
	case ESBlock_Gost28147_89_CryptoPro_C_ParamSet:
		sBlock = &Gost28147_CryptoProParamSetC;
		break;
	case ESBlock_Gost28147_89_CryptoPro_D_ParamSet:
		sBlock = &Gost28147_CryptoProParamSetD;
		break;
	case ESBlock_tc26_gost28147_param_Z:
		sBlock = &tc26_gost28147_paramZ;
		break;
	default:
		return STATUS_INVALID_PARAMETER;
	}

	switch (gostConfig->ChainingMode)
	{
	case ChainingMode_CFB:
		bIsCfb = TRUE;
		break;
	case ChainingMode_OFB:
		bIsCfb = FALSE;
		break;
	default:
		return STATUS_INVALID_PARAMETER;
	}

	c = (Gost89CipherContext *)ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(Gost89CipherContext), PoolTag);
	if (!c)
	{
		DEBUG("Failed to allocate memory for Gost89CipherContext\n");
		return STATUS_NO_MEMORY;
	}
	c->bIsCfb = bIsCfb;
	memset(&c->k, 0, sizeof(c->k));
	memset(&c->iv, 0, sizeof(c->iv));
	kboxinit(c, sBlock);

	*pOutContext = c;
	return STATUS_SUCCESS;
}

NTSTATUS Gost89CipherDestroy(PVOID ctx)
{
	if (!ctx)
		return STATUS_INVALID_PARAMETER;
	RtlSecureZeroMemory(((Gost89CipherContext *)ctx)->k, 32);
	ExFreePoolWithTag(ctx, PoolTag);
	return STATUS_SUCCESS;
}

NTSTATUS Gost89CipherInit(PVOID ctx, CONST VOID *key, CONST VOID *iv)
{
	Gost89CipherContext *gostCtx = (Gost89CipherContext *)ctx;
	if (!ctx)
		return STATUS_INVALID_PARAMETER;
	if (!key && !iv)
		return STATUS_INVALID_PARAMETER;
	if (iv) memmove(&gostCtx->iv, iv, sizeof(gostCtx->iv));
	if (key) gost_key(gostCtx, (const byte *)key);
	return STATUS_SUCCESS;
}

NTSTATUS Gost89CipherEncrypt(PVOID ctx, CONST VOID *plaintext, VOID *ciphertext, SIZE_T size)
{
	Gost89CipherContext *gostCtx = (Gost89CipherContext *)ctx;
	// expected a multiple of the block size
	if (0 != size % 8)
		return STATUS_INVALID_PARAMETER;
	if (!gostCtx || !plaintext || !ciphertext)
		return STATUS_INVALID_PARAMETER;
	if (gostCtx->bIsCfb)
		gost_enc_cfb(gostCtx, gostCtx->iv, (const byte *)plaintext, (byte *)ciphertext, (int)(size / 8));
	else
		gost_enc(gostCtx, (const byte *)plaintext, (byte *)ciphertext, (int)(size / 8));
	return STATUS_SUCCESS;
}

NTSTATUS Gost89CipherDecrypt(PVOID ctx, CONST VOID *ciphertext, VOID *plaintext, SIZE_T size)
{
	Gost89CipherContext *gostCtx = (Gost89CipherContext *)ctx;
	// expected a multiple of the block size
	if (0 != size % 8)
		return STATUS_INVALID_PARAMETER;
	if (!gostCtx || !plaintext || !ciphertext)
		return STATUS_INVALID_PARAMETER;
	if (gostCtx->bIsCfb)
		gost_dec_cfb(gostCtx, gostCtx->iv, (const byte *)ciphertext, (byte *)plaintext, (int)(size / 8));
	else
		gost_dec(gostCtx, (const byte *)ciphertext, (byte *)plaintext, (int)(size / 8));
	return STATUS_SUCCESS;
}

CipherEngine Gost89CipherEngine =
{
	.dwBlockSize =  8,
	.dwKeySize =    32,
	.pfnCreate =    Gost89CipherCreate,
	.pfnDestroy =   Gost89CipherDestroy,
	.pfnInit =      Gost89CipherInit,
	.pfnEncrypt =   Gost89CipherEncrypt,
	.pfnDecrypt =   Gost89CipherDecrypt
};

/* ****************************************************************************************
After this goes an algorithm implementation taken from openssl with minimum corrections
*******************************************************************************************/

#pragma region Openssl
/**********************************************************************
*                          gost_crypt.c                              *
*             Copyright (c) 2005-2006 Cryptocom LTD                  *
*         This file is distributed under the same license as OpenSSL *
*                                                                    *
*       OpenSSL interface to GOST 28147-89 cipher functions          *
*          Requires OpenSSL 0.9.9 for compilation                    *
**********************************************************************/

/*-
Substitution blocks from RFC 4357

Note: our implementation of gost 28147-89 algorithm
uses S-box matrix rotated 90 degrees counterclockwise, relative to
examples given in RFC.


*/

/* Substitution blocks from test examples for GOST R 34.11-94*/
gost_subst_block GostR3411_94_TestParamSet = {
	{ 0X1, 0XF, 0XD, 0X0, 0X5, 0X7, 0XA, 0X4, 0X9, 0X2, 0X3, 0XE, 0X6, 0XB, 0X8, 0XC },
	{ 0XD, 0XB, 0X4, 0X1, 0X3, 0XF, 0X5, 0X9, 0X0, 0XA, 0XE, 0X7, 0X6, 0X8, 0X2, 0XC },
	{ 0X4, 0XB, 0XA, 0X0, 0X7, 0X2, 0X1, 0XD, 0X3, 0X6, 0X8, 0X5, 0X9, 0XC, 0XF, 0XE },
	{ 0X6, 0XC, 0X7, 0X1, 0X5, 0XF, 0XD, 0X8, 0X4, 0XA, 0X9, 0XE, 0X0, 0X3, 0XB, 0X2 },
	{ 0X7, 0XD, 0XA, 0X1, 0X0, 0X8, 0X9, 0XF, 0XE, 0X4, 0X6, 0XC, 0XB, 0X2, 0X5, 0X3 },
	{ 0X5, 0X8, 0X1, 0XD, 0XA, 0X3, 0X4, 0X2, 0XE, 0XF, 0XC, 0X7, 0X6, 0X0, 0X9, 0XB },
	{ 0XE, 0XB, 0X4, 0XC, 0X6, 0XD, 0XF, 0XA, 0X2, 0X3, 0X8, 0X1, 0X0, 0X7, 0X5, 0X9 },
	{ 0X4, 0XA, 0X9, 0X2, 0XD, 0X8, 0X0, 0XE, 0X6, 0XB, 0X1, 0XC, 0X7, 0XF, 0X5, 0X3 }
};

/* Substitution blocks for hash function 1.2.643.2.9.1.6.1  */
gost_subst_block GostR3411_94_CryptoProParamSet = {
	{ 0x1, 0x3, 0xA, 0x9, 0x5, 0xB, 0x4, 0xF, 0x8, 0x6, 0x7, 0xE, 0xD, 0x0, 0x2, 0xC },
	{ 0xD, 0xE, 0x4, 0x1, 0x7, 0x0, 0x5, 0xA, 0x3, 0xC, 0x8, 0xF, 0x6, 0x2, 0x9, 0xB },
	{ 0x7, 0x6, 0x2, 0x4, 0xD, 0x9, 0xF, 0x0, 0xA, 0x1, 0x5, 0xB, 0x8, 0xE, 0xC, 0x3 },
	{ 0x7, 0x6, 0x4, 0xB, 0x9, 0xC, 0x2, 0xA, 0x1, 0x8, 0x0, 0xE, 0xF, 0xD, 0x3, 0x5 },
	{ 0x4, 0xA, 0x7, 0xC, 0x0, 0xF, 0x2, 0x8, 0xE, 0x1, 0x6, 0x5, 0xD, 0xB, 0x9, 0x3 },
	{ 0x7, 0xF, 0xC, 0xE, 0x9, 0x4, 0x1, 0x0, 0x3, 0xB, 0x5, 0x2, 0x6, 0xA, 0x8, 0xD },
	{ 0x5, 0xF, 0x4, 0x0, 0x2, 0xD, 0xB, 0x9, 0x1, 0x7, 0x6, 0x3, 0xC, 0xE, 0xA, 0x8 },
	{ 0xA, 0x4, 0x5, 0x6, 0x8, 0x1, 0x3, 0x7, 0xD, 0xC, 0xE, 0x0, 0x9, 0x2, 0xB, 0xF }
};

/* Test paramset from GOST 28147 */
gost_subst_block Gost28147_TestParamSet = {
	{ 0xC, 0x6, 0x5, 0x2, 0xB, 0x0, 0x9, 0xD, 0x3, 0xE, 0x7, 0xA, 0xF, 0x4, 0x1, 0x8 },
	{ 0x9, 0xB, 0xC, 0x0, 0x3, 0x6, 0x7, 0x5, 0x4, 0x8, 0xE, 0xF, 0x1, 0xA, 0x2, 0xD },
	{ 0x8, 0xF, 0x6, 0xB, 0x1, 0x9, 0xC, 0x5, 0xD, 0x3, 0x7, 0xA, 0x0, 0xE, 0x2, 0x4 },
	{ 0x3, 0xE, 0x5, 0x9, 0x6, 0x8, 0x0, 0xD, 0xA, 0xB, 0x7, 0xC, 0x2, 0x1, 0xF, 0x4 },
	{ 0xE, 0x9, 0xB, 0x2, 0x5, 0xF, 0x7, 0x1, 0x0, 0xD, 0xC, 0x6, 0xA, 0x4, 0x3, 0x8 },
	{ 0xD, 0x8, 0xE, 0xC, 0x7, 0x3, 0x9, 0xA, 0x1, 0x5, 0x2, 0x4, 0x6, 0xF, 0x0, 0xB },
	{ 0xC, 0x9, 0xF, 0xE, 0x8, 0x1, 0x3, 0xA, 0x2, 0x7, 0x4, 0xD, 0x6, 0x0, 0xB, 0x5 },
	{ 0x4, 0x2, 0xF, 0x5, 0x9, 0x1, 0x0, 0x8, 0xE, 0x3, 0xB, 0xC, 0xD, 0x7, 0xA, 0x6 }
};

/* 1.2.643.2.2.31.1 */
gost_subst_block Gost28147_CryptoProParamSetA = {
	{ 0xB, 0xA, 0xF, 0x5, 0x0, 0xC, 0xE, 0x8, 0x6, 0x2, 0x3, 0x9, 0x1, 0x7, 0xD, 0x4 },
	{ 0x1, 0xD, 0x2, 0x9, 0x7, 0xA, 0x6, 0x0, 0x8, 0xC, 0x4, 0x5, 0xF, 0x3, 0xB, 0xE },
	{ 0x3, 0xA, 0xD, 0xC, 0x1, 0x2, 0x0, 0xB, 0x7, 0x5, 0x9, 0x4, 0x8, 0xF, 0xE, 0x6 },
	{ 0xB, 0x5, 0x1, 0x9, 0x8, 0xD, 0xF, 0x0, 0xE, 0x4, 0x2, 0x3, 0xC, 0x7, 0xA, 0x6 },
	{ 0xE, 0x7, 0xA, 0xC, 0xD, 0x1, 0x3, 0x9, 0x0, 0x2, 0xB, 0x4, 0xF, 0x8, 0x5, 0x6 },
	{ 0xE, 0x4, 0x6, 0x2, 0xB, 0x3, 0xD, 0x8, 0xC, 0xF, 0x5, 0xA, 0x0, 0x7, 0x1, 0x9 },
	{ 0x3, 0x7, 0xE, 0x9, 0x8, 0xA, 0xF, 0x0, 0x5, 0x2, 0x6, 0xC, 0xB, 0x4, 0xD, 0x1 },
	{ 0x9, 0x6, 0x3, 0x2, 0x8, 0xB, 0x1, 0x7, 0xA, 0x4, 0xE, 0xF, 0xC, 0x0, 0xD, 0x5 }
};

/* 1.2.643.2.2.31.2 */
gost_subst_block Gost28147_CryptoProParamSetB = {
	{ 0x0, 0x4, 0xB, 0xE, 0x8, 0x3, 0x7, 0x1, 0xA, 0x2, 0x9, 0x6, 0xF, 0xD, 0x5, 0xC },
	{ 0x5, 0x2, 0xA, 0xB, 0x9, 0x1, 0xC, 0x3, 0x7, 0x4, 0xD, 0x0, 0x6, 0xF, 0x8, 0xE },
	{ 0x8, 0x3, 0x2, 0x6, 0x4, 0xD, 0xE, 0xB, 0xC, 0x1, 0x7, 0xF, 0xA, 0x0, 0x9, 0x5 },
	{ 0x2, 0x7, 0xC, 0xF, 0x9, 0x5, 0xA, 0xB, 0x1, 0x4, 0x0, 0xD, 0x6, 0x8, 0xE, 0x3 },
	{ 0x7, 0x5, 0x0, 0xD, 0xB, 0x6, 0x1, 0x2, 0x3, 0xA, 0xC, 0xF, 0x4, 0xE, 0x9, 0x8 },
	{ 0xE, 0xC, 0x0, 0xA, 0x9, 0x2, 0xD, 0xB, 0x7, 0x5, 0x8, 0xF, 0x3, 0x6, 0x1, 0x4 },
	{ 0x0, 0x1, 0x2, 0xA, 0x4, 0xD, 0x5, 0xC, 0x9, 0x7, 0x3, 0xF, 0xB, 0x8, 0x6, 0xE },
	{ 0x8, 0x4, 0xB, 0x1, 0x3, 0x5, 0x0, 0x9, 0x2, 0xE, 0xA, 0xC, 0xD, 0x6, 0x7, 0xF }
};

/* 1.2.643.2.2.31.3 */
gost_subst_block Gost28147_CryptoProParamSetC = {
	{ 0x7, 0x4, 0x0, 0x5, 0xA, 0x2, 0xF, 0xE, 0xC, 0x6, 0x1, 0xB, 0xD, 0x9, 0x3, 0x8 },
	{ 0xA, 0x9, 0x6, 0x8, 0xD, 0xE, 0x2, 0x0, 0xF, 0x3, 0x5, 0xB, 0x4, 0x1, 0xC, 0x7 },
	{ 0xC, 0x9, 0xB, 0x1, 0x8, 0xE, 0x2, 0x4, 0x7, 0x3, 0x6, 0x5, 0xA, 0x0, 0xF, 0xD },
	{ 0x8, 0xD, 0xB, 0x0, 0x4, 0x5, 0x1, 0x2, 0x9, 0x3, 0xC, 0xE, 0x6, 0xF, 0xA, 0x7 },
	{ 0x3, 0x6, 0x0, 0x1, 0x5, 0xD, 0xA, 0x8, 0xB, 0x2, 0x9, 0x7, 0xE, 0xF, 0xC, 0x4 },
	{ 0x8, 0x2, 0x5, 0x0, 0x4, 0x9, 0xF, 0xA, 0x3, 0x7, 0xC, 0xD, 0x6, 0xE, 0x1, 0xB },
	{ 0x0, 0x1, 0x7, 0xD, 0xB, 0x4, 0x5, 0x2, 0x8, 0xE, 0xF, 0xC, 0x9, 0xA, 0x6, 0x3 },
	{ 0x1, 0xB, 0xC, 0x2, 0x9, 0xD, 0x0, 0xF, 0x4, 0x5, 0x8, 0xE, 0xA, 0x7, 0x6, 0x3 }
};

/* 1.2.643.2.2.31.4 */
gost_subst_block Gost28147_CryptoProParamSetD = {
	{ 0x1, 0xA, 0x6, 0x8, 0xF, 0xB, 0x0, 0x4, 0xC, 0x3, 0x5, 0x9, 0x7, 0xD, 0x2, 0xE },
	{ 0x3, 0x0, 0x6, 0xF, 0x1, 0xE, 0x9, 0x2, 0xD, 0x8, 0xC, 0x4, 0xB, 0xA, 0x5, 0x7 },
	{ 0x8, 0x0, 0xF, 0x3, 0x2, 0x5, 0xE, 0xB, 0x1, 0xA, 0x4, 0x7, 0xC, 0x9, 0xD, 0x6 },
	{ 0x0, 0xC, 0x8, 0x9, 0xD, 0x2, 0xA, 0xB, 0x7, 0x3, 0x6, 0x5, 0x4, 0xE, 0xF, 0x1 },
	{ 0x1, 0x5, 0xE, 0xC, 0xA, 0x7, 0x0, 0xD, 0x6, 0x2, 0xB, 0x4, 0x9, 0x3, 0xF, 0x8 },
	{ 0x1, 0xC, 0xB, 0x0, 0xF, 0xE, 0x6, 0x5, 0xA, 0xD, 0x4, 0x8, 0x9, 0x3, 0x7, 0x2 },
	{ 0xB, 0x6, 0x3, 0x4, 0xC, 0xF, 0xE, 0x2, 0x7, 0xD, 0x8, 0x0, 0x5, 0xA, 0x9, 0x1 },
	{ 0xF, 0xC, 0x2, 0xA, 0x6, 0x4, 0x5, 0x0, 0x7, 0x9, 0xE, 0xD, 0x1, 0xB, 0x8, 0x3 }
};

/** 1.2.643.7.1.2.5.1.1 */
gost_subst_block tc26_gost28147_paramZ = {
	{ 0x1, 0x7, 0xE, 0xD, 0x0, 0x5, 0x8, 0x3, 0x4, 0xF, 0xA, 0x6, 0x9, 0xC, 0xB, 0x2 },
	{ 0x8, 0xE, 0x2, 0x5, 0x6, 0x9, 0x1, 0xC, 0xF, 0x4, 0xB, 0x0, 0xD, 0xA, 0x3, 0x7 },
	{ 0x5, 0xD, 0xF, 0x6, 0x9, 0x2, 0xC, 0xA, 0xB, 0x7, 0x8, 0x1, 0x4, 0x3, 0xE, 0x0 },
	{ 0x7, 0xF, 0x5, 0xA, 0x8, 0x1, 0x6, 0xD, 0x0, 0x9, 0x3, 0xE, 0xB, 0x4, 0x2, 0xC },
	{ 0xC, 0x8, 0x2, 0x1, 0xD, 0x4, 0xF, 0x6, 0x7, 0x0, 0xA, 0x5, 0x3, 0xE, 0x9, 0xB },
	{ 0xB, 0x3, 0x5, 0x8, 0x2, 0xF, 0xA, 0xD, 0xE, 0x1, 0x7, 0x4, 0xC, 0x9, 0x6, 0x0 },
	{ 0x6, 0x8, 0x2, 0x3, 0x9, 0xA, 0x5, 0xC, 0x1, 0xE, 0x4, 0x7, 0xB, 0xD, 0x0, 0xF },
	{ 0xC, 0x4, 0x6, 0x2, 0xA, 0x5, 0xB, 0x9, 0xE, 0x8, 0xD, 0x7, 0x0, 0x3, 0xF, 0x1 }
};

/* Initialization of gost_ctx subst blocks*/
static void kboxinit(Gost89CipherContext * c, const gost_subst_block * b)
{
	int i;

	for (i = 0; i < 256; i++) {
		c->k87[i] = (word32)(b->k8[i >> 4] << 4 | b->k7[i & 15]) << 24;
		c->k65[i] = (b->k6[i >> 4] << 4 | b->k5[i & 15]) << 16;
		c->k43[i] = (b->k4[i >> 4] << 4 | b->k3[i & 15]) << 8;
		c->k21[i] = b->k2[i >> 4] << 4 | b->k1[i & 15];

	}
}

/* Part of GOST 28147 algorithm moved into separate function */
static word32 f(Gost89CipherContext * c, word32 x)
{
	x = c->k87[x >> 24 & 255] | c->k65[x >> 16 & 255] |
		c->k43[x >> 8 & 255] | c->k21[x & 255];
	/* Rotate left 11 bits */
	return x << 11 | x >> (32 - 11);
}

/* Low-level encryption routine - encrypts one 64 bit block*/
void gostcrypt(Gost89CipherContext * c, const byte * in, byte * out)
{
	register word32 n1, n2;     /* As named in the GOST */
	n1 = in[0] | (in[1] << 8) | (in[2] << 16) | ((word32)in[3] << 24);
	n2 = in[4] | (in[5] << 8) | (in[6] << 16) | ((word32)in[7] << 24);
	/* Instead of swapping halves, swap names each round */

	n2 ^= f(c, n1 + c->k[0]);
	n1 ^= f(c, n2 + c->k[1]);
	n2 ^= f(c, n1 + c->k[2]);
	n1 ^= f(c, n2 + c->k[3]);
	n2 ^= f(c, n1 + c->k[4]);
	n1 ^= f(c, n2 + c->k[5]);
	n2 ^= f(c, n1 + c->k[6]);
	n1 ^= f(c, n2 + c->k[7]);

	n2 ^= f(c, n1 + c->k[0]);
	n1 ^= f(c, n2 + c->k[1]);
	n2 ^= f(c, n1 + c->k[2]);
	n1 ^= f(c, n2 + c->k[3]);
	n2 ^= f(c, n1 + c->k[4]);
	n1 ^= f(c, n2 + c->k[5]);
	n2 ^= f(c, n1 + c->k[6]);
	n1 ^= f(c, n2 + c->k[7]);

	n2 ^= f(c, n1 + c->k[0]);
	n1 ^= f(c, n2 + c->k[1]);
	n2 ^= f(c, n1 + c->k[2]);
	n1 ^= f(c, n2 + c->k[3]);
	n2 ^= f(c, n1 + c->k[4]);
	n1 ^= f(c, n2 + c->k[5]);
	n2 ^= f(c, n1 + c->k[6]);
	n1 ^= f(c, n2 + c->k[7]);

	n2 ^= f(c, n1 + c->k[7]);
	n1 ^= f(c, n2 + c->k[6]);
	n2 ^= f(c, n1 + c->k[5]);
	n1 ^= f(c, n2 + c->k[4]);
	n2 ^= f(c, n1 + c->k[3]);
	n1 ^= f(c, n2 + c->k[2]);
	n2 ^= f(c, n1 + c->k[1]);
	n1 ^= f(c, n2 + c->k[0]);

	out[0] = (byte)(n2 & 0xff);
	out[1] = (byte)((n2 >> 8) & 0xff);
	out[2] = (byte)((n2 >> 16) & 0xff);
	out[3] = (byte)(n2 >> 24);
	out[4] = (byte)(n1 & 0xff);
	out[5] = (byte)((n1 >> 8) & 0xff);
	out[6] = (byte)((n1 >> 16) & 0xff);
	out[7] = (byte)(n1 >> 24);
}

/* Low-level decryption routine. Decrypts one 64-bit block */
void gostdecrypt(Gost89CipherContext * c, const byte * in, byte * out)
{
	register word32 n1, n2;     /* As named in the GOST */
	n1 = in[0] | (in[1] << 8) | (in[2] << 16) | ((word32)in[3] << 24);
	n2 = in[4] | (in[5] << 8) | (in[6] << 16) | ((word32)in[7] << 24);

	n2 ^= f(c, n1 + c->k[0]);
	n1 ^= f(c, n2 + c->k[1]);
	n2 ^= f(c, n1 + c->k[2]);
	n1 ^= f(c, n2 + c->k[3]);
	n2 ^= f(c, n1 + c->k[4]);
	n1 ^= f(c, n2 + c->k[5]);
	n2 ^= f(c, n1 + c->k[6]);
	n1 ^= f(c, n2 + c->k[7]);

	n2 ^= f(c, n1 + c->k[7]);
	n1 ^= f(c, n2 + c->k[6]);
	n2 ^= f(c, n1 + c->k[5]);
	n1 ^= f(c, n2 + c->k[4]);
	n2 ^= f(c, n1 + c->k[3]);
	n1 ^= f(c, n2 + c->k[2]);
	n2 ^= f(c, n1 + c->k[1]);
	n1 ^= f(c, n2 + c->k[0]);

	n2 ^= f(c, n1 + c->k[7]);
	n1 ^= f(c, n2 + c->k[6]);
	n2 ^= f(c, n1 + c->k[5]);
	n1 ^= f(c, n2 + c->k[4]);
	n2 ^= f(c, n1 + c->k[3]);
	n1 ^= f(c, n2 + c->k[2]);
	n2 ^= f(c, n1 + c->k[1]);
	n1 ^= f(c, n2 + c->k[0]);

	n2 ^= f(c, n1 + c->k[7]);
	n1 ^= f(c, n2 + c->k[6]);
	n2 ^= f(c, n1 + c->k[5]);
	n1 ^= f(c, n2 + c->k[4]);
	n2 ^= f(c, n1 + c->k[3]);
	n1 ^= f(c, n2 + c->k[2]);
	n2 ^= f(c, n1 + c->k[1]);
	n1 ^= f(c, n2 + c->k[0]);

	out[0] = (byte)(n2 & 0xff);
	out[1] = (byte)((n2 >> 8) & 0xff);
	out[2] = (byte)((n2 >> 16) & 0xff);
	out[3] = (byte)(n2 >> 24);
	out[4] = (byte)(n1 & 0xff);
	out[5] = (byte)((n1 >> 8) & 0xff);
	out[6] = (byte)((n1 >> 16) & 0xff);
	out[7] = (byte)(n1 >> 24);
}

/* Encrypts several blocks in ECB mode */
void gost_enc(Gost89CipherContext * c, const byte * clear, byte * cipher, int blocks)
{
	int i;
	for (i = 0; i < blocks; i++) {
		gostcrypt(c, clear, cipher);
		clear += 8;
		cipher += 8;
	}
}

/* Decrypts several blocks in ECB mode */
void gost_dec(Gost89CipherContext * c, const byte * cipher, byte * clear, int blocks)
{
	int i;
	for (i = 0; i < blocks; i++) {
		gostdecrypt(c, cipher, clear);
		clear += 8;
		cipher += 8;
	}
}

/* Encrypts several full blocks in CFB mode using 8byte IV */
void gost_enc_cfb(Gost89CipherContext * ctx, const byte * iv, const byte * clear,
	byte * cipher, int blocks)
{
	byte cur_iv[8];
	byte gamma[8];
	int i, j;
	const byte *in;
	byte *out;
	memcpy(cur_iv, iv, 8);
	for (i = 0, in = clear, out = cipher; i < blocks; i++, in += 8, out += 8) {
		gostcrypt(ctx, cur_iv, gamma);
		for (j = 0; j < 8; j++) {
			cur_iv[j] = out[j] = in[j] ^ gamma[j];
		}
	}
}

/* Decrypts several full blocks in CFB mode using 8byte IV */
void gost_dec_cfb(Gost89CipherContext * ctx, const byte * iv, const byte * cipher,
	byte * clear, int blocks)
{
	byte cur_iv[8];
	byte gamma[8];
	int i, j;
	const byte *in;
	byte *out;
	memcpy(cur_iv, iv, 8);
	for (i = 0, in = cipher, out = clear; i < blocks; i++, in += 8, out += 8) {
		gostcrypt(ctx, cur_iv, gamma);
		for (j = 0; j < 8; j++) {
			out[j] = (cur_iv[j] = in[j]) ^ gamma[j];
		}
	}
}

/* Set 256 bit  key into context */
void gost_key(Gost89CipherContext * c, const byte * k)
{
	int i, j;
	for (i = 0, j = 0; i < 8; i++, j += 4) {
		c->k[i] =
			k[j] | (k[j + 1] << 8) | (k[j + 2] << 16) | ((word32)k[j + 3] <<
			24);
	}
}

#pragma endregion
